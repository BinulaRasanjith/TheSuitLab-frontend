import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import jwtDecode from "jwt-decode";

import api from "../../api/api";
import { login as loginAPI, logout as logoutAPI, signup as signupAPI } from "../../api/authAPIs";

const initialState = {
	user: {
		id: null,
		firstName: null,
		lastName: null,
		mobileNo: null,
		email: null,
		role: null,
	},
	status: 'idle',
	error: null,
};

export const loginAsync = createAsyncThunk( // this thunk will make a POST request to the /auth/login endpoint of the server. It will return a promise that will resolve to the response from the server. 
	'auth/login', // the name of the thunk. It will be used as the prefix for the action types generated by the createAsyncThunk function. 
	async (payload) => { // the payload is the data that is passed to the thunk when it is dispatched. In this case, the payload will be the data entered by the user in the login form.
		try { // try to make the POST request to the /auth/login endpoint of the server.
			const response = await loginAPI(payload);
			const { accessToken, message } = response.data; // get the access token and the message from the response.

			api.defaults.headers.common.Authorization = `Bearer ${accessToken}`; // set the access token in the api module. This will be used to make authenticated requests to the server.
			localStorage.setItem("accessToken", accessToken); // set the access token in the local storage. This will be used to persist the login state of the user.

			const decodedJWT = await jwtDecode(accessToken); // decode the access token to get the user data. The access token contains the user data in the payload.

			const user = setUserObject(decodedJWT.user)

			return { user }; // return the user data and the message
		}
		catch (error) {
			return Promise.reject(error); // if the request fails, reject the promise with the error
		}
	}
);

export const signupAsync = createAsyncThunk( // this thunk will make a POST request to the /auth/signup endpoint of the server. It will return a promise that will resolve to the response from the server.
	'auth/signup',
	async (payload) => { // the payload is the data that is passed to the thunk when it is dispatched. In this case, the payload will be the data entered by the user in the signup form. 
		try {
			const response = await signupAPI(payload); // try to make the POST request to the /auth/signup endpoint of the server.
			const { user, message } = response.data; // get the user data and the message from the response.

			return { user, message }; // return the user data and the message
		}
		catch (error) { // if the request fails, reject the promise with the error
			return Promise.reject(error);
		}
	}
);


const authSlice = createSlice({ // create the auth slice
	name: 'auth', // the name of the slice. This will be used as the prefix for the action types generated by the createSlice function.
	initialState, // the initial state of the slice
	reducers: { // the reducers of the slice
		logout: (state) => { // this reducer will be used to logout the user. It will remove the access token from the local storage and the api module. It will also reset the user state.
			logoutAPI(); // make a POST request to the /auth/logout endpoint of the server.
			localStorage.removeItem("accessToken"); // remove the access token from the local storage
			api.defaults.headers.common.Authorization = null; // remove the access token from the api module
			state.user = initialState.user; // reset the user state
		},
		setUser: (state, action) => { // this reducer will be used to set the user state of the slice. It will be used to persist the login state of the user.
			state.user = action.payload; // set the user state to the user data passed to the reducer
		},
		setError: (state, action) => { // this reducer will be used to set the error state of the slice. It will be used to display the error message to the user.
			state.error = action.payload; // set the error state to the error message passed to the reducer
		}
	},
	extraReducers: (builder) => { // the extra reducers of the slice. These reducers will be generated by the createAsyncThunk function. They will be used to update the status and the user state of the slice.
		builder
			// loginAsync reducers
			.addCase(loginAsync.pending, (state) => { // this reducer will be called when the loginAsync thunk is dispatched. It will set the status state to loading.
				state.status = 'loading';
			})
			.addCase(loginAsync.fulfilled, (state, action) => { // this reducer will be called when the loginAsync thunk is fulfilled. It will set the status state to idle and set the user state to the user data returned by the thunk.
				state.status = 'idle';
				state.user = action.payload.user;
				state.message = action.payload.message;
			})
			.addCase(loginAsync.rejected, (state, action) => { // this reducer will be called when the loginAsync thunk is rejected. It will set the status state to idle and set the error state to the error message returned by the thunk.
				state.status = 'idle';
				state.error = action.error.message;
			})
	}
});

export function setUserObject(user) {
	return {
		id: user.id,
		firstName: user.firstName,
		lastName: user.lastName,
		mobileNo: user.mobileNo,
		email: user.email,
		role: user.role,
	}
}


export const selectUser = (state) => state.auth.user;
export const selectAuthStatus = (state) => state.auth.status;
export const selectAuthError = (state) => state.auth.error;

export const { logout, setError, setUser } = authSlice.actions;
export default authSlice.reducer;